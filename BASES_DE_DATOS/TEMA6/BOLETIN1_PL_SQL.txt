EJERCICIO 1. Crea una función que sume dos números y devuelva el resultado. Realiza una
llamada a dicha función desde un bloque anónimo.
	
* 1 forma de resolver*

	DECLARE

		v_num1 INT;
		v_num2 INT;
		v_num3 INT;

	BEGIN

		v_num1 := 10;
		v_num2 := 8;

		v_num3:= v_num1 + v_num2;

		dbms_output.put_line('la suma de los dos numeros es ' || v_num3);

	END;
	
	
	
	
		
*2 forma de resolver*

	create or replace function sumar (num1 in number,num2 in number) return number
	is
		total number;
	begin
		total := num1 + num2;
		return total;
	end;
	/

	declare
		resultado number;
	begin
		resultado := sumar(5,5);
		dbms_output.put_line('El resultado es: '|| resultado);
	end;
	

EJERCICIO 2. Crear una función que calcule el área de un triángulo dado su base y altura.
Realiza una llamada a dicha función desde un bloque anónimo.


	DECLARE

		v_base INT;
		v_altura INT;
		v_area INT;

	BEGIN

		v_base := 10;
		v_altura := 8;

		v_area:= v_base * v_altura /2;

		dbms_output.put_line('El area del triangulo es ' || v_area);

	END;
	
	
EJERCICIO 3. Crea una función que determine si un número dado es par o impar. Realiza una
llamada a dicha función desde un bloque anónimo.

	DECLARE
		numero INT;
		
	BEGIN

		numero := 11;

		IF (MOD(numero,2)= 0) then 

		dbms_output.put_line('El numero es par');
		ELSE
			dbms_output.put_line('El numero es impar');
		END IF;
	END;


EJERCICIO 4. Crea una función que calcule el factorial de un número dado. Realiza una
llamada a dicha función desde un bloque anónimo.


	DECLARE
		num NUMBER := 8;
		fact NUMBER;
		
		FUNCTION calcular_factorial(numero IN NUMBER) RETURN NUMBER IS
			resultado NUMBER := 1;

		BEGIN IF numero < 0 THEN

			RETURN NULL;
		
		ELSIF numero = 0 THEN
		
			RETURN 1;
			ELSE
				FOR i IN 1..numero LOOP
					resultado := resultado * i;
				END LOOP;
				RETURN resultado;
			END IF;
		END calcular_factorial;
	BEGIN
		fact := calcular_factorial(num);
		DBMS_OUTPUT.PUT_LINE('El factorial de ' || num || ' es ' || fact);
	END;


EJERCICIO 5. Crea una función que determine si un número dado es primo o no. Realiza una
llamada a dicha función desde un bloque anónimo.

	DECLARE
		
		num NUMBER := 1; 
		es_primo BOOLEAN;


		FUNCTION es_numero_primo(numero IN NUMBER) RETURN BOOLEAN IS
			es_primo BOOLEAN := TRUE;
		BEGIN
			IF numero <= 1 THEN
				es_primo := FALSE;
			ELSE
				FOR i IN 2..TRUNC(SQRT(numero)) LOOP
					IF MOD(numero, i) = 0 THEN
						es_primo := FALSE;
						EXIT;
					END IF;
				END LOOP;
			END IF;
			RETURN es_primo;
		END es_numero_primo;
	BEGIN
		
		es_primo := es_numero_primo(num);

		IF es_primo THEN
			DBMS_OUTPUT.PUT_LINE(num || ' es un número primo.');
		ELSE
			DBMS_OUTPUT.PUT_LINE(num || ' no es un número primo.');
		END IF;
	END;


EJERCICIO 6. Crea una función que determine si una cadena dada es un palíndromo o no.
Realiza una llamada a dicha función desde un bloque anónimo.

	DECLARE
		cadena VARCHAR2(100) := 'radar'; 
		cadena_inversa VARCHAR2(100) := '';
		es_palindromo BOOLEAN := TRUE;
	BEGIN

		FOR i IN REVERSE 1..LENGTH(cadena) LOOP
			cadena_inversa := cadena_inversa || SUBSTR(cadena, i, 1);
		END LOOP;


		FOR i IN 1..LENGTH(cadena) LOOP
			IF SUBSTR(cadena, i, 1) != SUBSTR(cadena_inversa, i, 1) THEN
				es_palindromo := FALSE;
				EXIT;
			END IF;
		END LOOP;


		IF es_palindromo THEN
			DBMS_OUTPUT.PUT_LINE('La cadena "' || cadena || '" es un palíndromo.');
		ELSE
			DBMS_OUTPUT.PUT_LINE('La cadena "' || cadena || '" no es un palíndromo.');
		END IF;
	END;


